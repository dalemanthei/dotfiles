#!/usr/local/bin/node --harmony
var cp = require('child_process');
var execSync = require('child_process').execFileSync;
module.paths.push('/usr/local/lib/node_modules');  // hacky hacky hacky to get to async
var async = require('async');

// The git commands below will list the files which have been staged but the checks may be run against a
// copy of the file which is not the same as will be committed. This means that the checks may fail on the
// unstaged version of the file but the staged version will pass fine.

var getJsFiles = 'git diff --cached --name-only --diff-filter=ACM | grep ".js$"';
var getFiles = 'git diff --cached --name-only --diff-filter=ACM';

var projectDir = __dirname.split('.git')[0];
var failCount = 0;
var testResults;
var files = [];
var jsFiles = [];

gitFiles();

if (jsFiles.length === 0) {
	console.log('No JavaScript files to validate');
	process.exit(99);
}

checkJsFiles(jsFiles);

if (!failCount) {
	runUnitTests();
}

if (failCount > 0) {
	console.log('\n\033[41mCOMMIT FAILED:\033[0m Your commit contains files that do not pass one or more checks. ' +
		'Please fix the errors and try again.\n');
	process.exit(failCount);
} else {
	console.log('\n\033[32m 🍺  COMMIT SUCCEEDED\033[0m\n');
}

// ****** private functions ******


function gitFiles() {

	try {
		cp.execSync(getFiles, {encoding: 'utf8'}).split(/\r?\n/).forEach(function (line) {
			if (line.length > 0) {
				files.push(line);
			}
		});
	} catch (e) {
		console.log(e.message);
		process.exit(-2);
	}
	console.log(files);

	files.forEach(function (file) {
		if (file.slice(-3) === '.js') {
			jsFiles.push(file);
		}
	});

}


function checkJsFiles(jsFiles) {
	console.log('\n\033[36mJavaScript validation:\033[0m');
	async.forEachSeries(jsFiles, function (file, callback) {
		process.stdout.write('\n\t\033[36mChecking ' + file + '\033[0m ');
		jsHint(file);
		jscs(file);
		scan(file);
		callback();
	});
	console.log('\n\n\033[36mJavaScript validation complete\033[0m');
}


function runUnitTests() {
	console.log('\n\033[36mUnit Tests:\033[0m');
	process.stdout.write('\n\t\033[36mRunning client unit tests:\033[0m ');
	try {
		cp.execSync('gulp test-tdd', {cwd: projectDir + 'client/', encoding: 'utf8'});
		pass('SUCCESS');
	} catch (e) {
		fail('FAILED');
	}
	console.log('\n\n\033[36mUnit Tests complete\033[0m');
}


function jsHint(file) {
	try {
		cp.execSync('jshint ' + file, {cwd: projectDir, encoding: 'utf8'});
		pass('JSHint');
	} catch (e) {
		fail('JSHint');
	}
}


function jscs(file) {
	try {
		cp.execSync('jscs ' + file, {cwd: projectDir, encoding: 'utf8'});
		pass('JSCS');
	} catch (e) {
		fail('JSCS');
	}
}

function scan(file) {
	try {
		// The grep console log will avoid console.log statements that are on line comments but not block comments
		// $searchString =~ m/^[\w].*console.log/sm
		// var result = cp.execSync('egrep -e \'^\s*console.log\' -e debugger ' + file + ' -m 1 | wc -l', {cwd: projectDir, encoding: 'utf8'});
		// var result = cp.execSync('egrep -e \'\^\s*console.log\' -e debugger ' + file, {cwd: projectDir, encoding: 'utf8'});
		var result = cp.execSync('egrep -e debugger ' + file, {cwd: projectDir, encoding: 'utf8'});
		console.log(result);
		if (result.trim() !== '0') {
			fail('Scan');
		} else {
			pass('Scan');
		}
	} catch (e) {
		fail('Scan');
	}
}


function pass(message) {
	process.stdout.write('\033[32m' + message + '\033[0m ');
}


function fail(message) {
	process.stdout.write('\033[31m' + message + '\033[0m ');
	failCount += 1;
}
